/*
    Clashing Coders RPG Platform - The platform used for Creamfinance's first coding contest.
    Copyright (C) 2016 Thomas Rosenstein

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

function indent(str) {
    return str.split('\n').reduce(function (prev, str) {
        return prev + [' '].repeat(3).join('') + str + '\n';
    }, '');
}

var FieldValidator = Class.bind(null, 'FieldValidator', Object);

FieldValidator({
    constructor: function (fieldName, definition) {
        this.fieldName = fieldName;
        this.rules = [];
        this.children = [];

        if (definition && 
            definition instanceof Object && 
            '^' in definition) {
            this.addRules(definition['^']);
        }

        if (definition instanceof ValidationRule) {
            this.rules.push(definition);
        }

        if (definition instanceof Object && 
            !(definition instanceof ValidationRule) &&
            !(definition instanceof Array)) {
            for (var field in definition) {
                if (field == '^') {
                    continue;
                }

                this.children.push(new FieldValidator(field, definition[field]))
            }
        } else if (definition instanceof Array) {
            for (var i = 0; i < definition.length; i++) {
                this.rules.push(definition[i]);
            }
        }
    },
    addRules: function (ruleDefinitions) {
        if (ruleDefinitions instanceof Array) {
            // check if every member is a ValidationRule
            var okay = true;

            for (var i = 0; i < ruleDefinitions.length; i++) {
                if (!(ruleDefinitions[i] instanceof ValidationRule)) {
                    okay = false;
                    break;
                }
            }

            // Add all the rules
            if (okay) {
                for (var i = 0; i < ruleDefinitions.length; i++) {
                    this.rules.push(ruleDefinitions[i])
                }
            }
        } else if (ruleDefinitions instanceof ValidationRule) {
            this.rules.push(ruleDefinitions);
        } else {
            console.log('Invalid Rule Definiton: ', ruleDefinitions);
        }
    },
    /* Crazy validate function */
    validate: function (context, fullData, currentValue, callback) {
        var target = currentValue;

        var failed = false;

        // Create a wait check handler for the children and the field
        var ch = new CompletionHandler();
        var preWait = ch.wait('D');

        // determines if a subcheck was successful
        var doneCheck = function (done, result) {
            if (!result) {
                failed = true;
            }

            done();
        };

        // validated the current field - fieldName may be null for the first layer
        if (this.fieldName !== '^') {
            // got down the fieldname, or if it's not set return null
            if (currentValue && this.fieldName in currentValue) {
                target = currentValue[this.fieldName];
            } else {
                target = null;
            }

            this.validateField(context, fullData, target, doneCheck.bind(this, ch.wait('D')));
        } else {
            // if the fieldName is null, we need to validate our own rules
            this.validateField(context, fullData, fullData, doneCheck.bind(this, ch.wait('D')));
        }

        // validated the children of the current field
        for (var i = 0; i < this.children.length; i++) {
            this.children[i].validate(
                (this.fieldName ? context.fields[this.fieldName] : context),
                fullData,
                target,
                doneCheck.bind(this, ch.wait('D'))
            );
        }

        // handles the final check and updates the context
        ch.handle('D', function () {
            context.success = !failed;
            callback(!failed);
        });

        preWait();
    },
    validateField: function (context, fullData, target, callback) {
        var failed = false;

        // Create a wait check handler for the current fields
        var ch = new CompletionHandler();
        var preWait = ch.wait('D');

        var doneCheck = function (done, result) {
            if (!result) {
                failed = true;
            }

            done();
        };

        // create a new context for this field
        context.fields[this.fieldName] = { errors: [], success: true, fields: {} };

        // validate each of the rules for the current field
        for (var i = 0; i < this.rules.length; i++) {
            this.rules[i].validate(
                context.fields[this.fieldName],
                fullData,
                target,
                doneCheck.bind(this, ch.wait('D'))
            );
        }

        // finish waiting for all checks, and update the context
        ch.handle('D', function () {
            context.fields[this.fieldName].success = !failed;
            callback(!failed);
        }.bind(this));

        preWait();
    },
    inspect: function () {
        return this.toString();
    },
    toString: function () {
        var item = 'FieldValidator (' + this.fieldName + ', ' + this.rules.length + ')';

        item += '\nRules:[';

        item += '\n]';

        item += '\nChildren:[';

        for (var i = 0; i < this.children.length; i++) {
            item += '\n' + indent(this.children[i].toString() + ',');
        }

        item += '\n]';

        return item;
    }
});

FieldValidator = global.FieldValidator;
