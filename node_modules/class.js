/*
    Clashing Coders RPG Platform - The platform used for Creamfinance's first coding contest.
    Copyright (C) 2016 Thomas Rosenstein

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

if (typeof global == 'undefined') {
    window.global = window;
}

var vm = require('vm');
var fs = require('fs');
var _glob = global || window;

module.exports = Class;
_glob.Class = Class;
function Class(classname, parent, config, container)
{
    container = container || _glob;
    config.class = config.class || classname;

    if (config.hasOwnProperty('constructor')) {
        create = config.constructor;
    } else {
        eval('var create = function ' + config.class + "() { var args = Array.prototype.slice.call(arguments); if ('init' in this) this.init.apply(this, args); }");
    }

    var namespace = config.namespace;

    var proto = config;
    proto.__proto__ = parent.prototype;
    proto.super = parent.prototype;

    create.prototype = proto;

    if (namespace) {
        if (!(namespace in container)) {
            container[namespace] = {};
        }

        if (config.class in container[namespace]) {
            log(config.class + ' already defined, overwriting!');
        }
        
        container[namespace][config.class] = create;
    } else {
        if (config.class in container) {
            log(config.class + ' already defined, overwriting!');
        }

        container[config.class] = create;
    }

    return create;
};

_glob.printStacktrace = function (e) {
    if (typeof e != 'object' || !('stack' in e)) {
        e = null;
    }
    e = e || new Error('dummy');
    var stack = (e.stack || 'NO STACKTRACE!')
      //.replace(/^[^\(]+?[\n$]/gm, '')
      .replace(/^\s+at\s+/gm, '')
      .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
      .split('\n');
    log(stack);
};

_glob.F = function (obj, prop, value) {
    Object.defineProperty(obj, prop, { value: value, enumerable: false, writable: true, configurable: true });
};

F(Date.prototype, 'toDbDate', function () {
    var date = this;

    var y = pad(date.getUTCFullYear(), 4, '0', STR_PAD_LEFT);
    var m = pad(date.getUTCMonth() + 1, 2, '0', STR_PAD_LEFT);
    var d = pad(date.getUTCDate(), 2, '0', STR_PAD_LEFT);

    var h = pad(date.getUTCHours(), 2, '0', STR_PAD_LEFT);
    var i = pad(date.getUTCMinutes(), 2, '0', STR_PAD_LEFT);
    var s = pad(date.getUTCSeconds(), 2, '0', STR_PAD_LEFT);


    return y + '-' + m + '-' + d + ' ' + h + ':' + i + ':' + s;
});

F(Object.prototype,
    '__callParent',
    function (name) {
        if (!this.callstack) {
            this.callstack = [];
        }

        var lastImage = null;

        if (this.callstack.length > 0) {
            lastImage = this.callstack[this.callstack.length - 1];
        }

        // detect if method is not contained
        // move up the hierarchy to start at the correct
        // 'super implementation'
        var temp = this.__proto__;
        while (!temp.hasOwnProperty(name)) {
            temp = temp.super;

            if (!temp) {
                temp = this;
                break;
            }
        }

        temp = temp.super;

        if (lastImage && lastImage.func == name) {
            temp = lastImage.super.super;
        }

        var stackImage = { func: name, super: temp };
        this.callstack.push(stackImage);

        var func = temp[name];

        try {
            if (!func) {

                if (name.indexOf('get ') === 0) {
                    name = name.substring(4);
                } else if (name.indexOf('set ') === 0) {
                    name = name.substring(4);
                }

                // calling a getter
                if (arguments.length == 1) {
                    func = temp.__lookupGetter__(name);
                } else if (arguments.length == 2) {
                    // calling a setter
                    func = temp.__lookupSetter__(name);
                }
            }

            if (!func) {
                log(temp.class + ' has no method ' + name);
            } else {
                var args = Array.prototype.slice.call(arguments);
                args.splice(0, 1);
                return func.apply(this, args);
            }
        } finally {
            this.callstack.pop();
        }
    }
);

F(Object.prototype,
    '__event',
    function (eventname, args) {
        var that = this;

        if (!this._events) {
            this._events = {};
        }

        if (!(eventname in this._events)) {
            this._events[eventname] = [];
        }

        if (args.length == 1 && args[0] instanceof Function) {
            this._events[eventname].push(args[0]);
        } else {
            for (var i = 0; i < this._events[eventname].length; i++) {
                this._events[eventname][i].apply(that, args);
            }
        }
        return this;
    }
);
